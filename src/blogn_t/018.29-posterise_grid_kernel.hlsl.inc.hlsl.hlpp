#SMALL_START#
typedef float3 point_t;
#include "shader.h"

[[vk::binding(0)]] RWStructuredBuffer<float3>          outputs;            // HOST_VISIBLE
[[vk::binding(1)]]   StructuredBuffer<params_t>        params;             // DEVICE_LOCAL & HOST_VISIBLE
[[vk::binding(2)]]   StructuredBuffer<known_rgbs_pack> known_rgbs_bundle;  // DEVICE_LOCAL & HOST_VISIBLE
/*            3 */   KNOWN_RGBS_FREQS
[[vk::binding(4)]]   StructuredBuffer<uint>            groups_data;        // DEVICE_LOCAL

[numthreads(64, 1, 1)]
void main(uint3 DTid : SV_DispatchThreadID) {
	const uint   known_rgbs_len   = params[0].known_rgbs_len;
	const float  radiussy_squared = params[0].radiussy_squared;
	const uint   iter_limit       = params[0].iter_limit;
	const float3 bbox_min         = params[0].bbox_min;
	const float3 bbox_range       = params[0].bbox_range;
	const uint3  grid_bothdir     = params[0].grid_bothdirs;

	const uint id = DTid.x;
	if(id >= known_rgbs_len)
		return;

	known_rgbs_pack this = known_rgbs_bundle[id];
	float3 center = this.lab;
	for(int iter = 0; iter != iter_limit; ++iter) {
#SMALL_END#
		const uint3 gridpos      = trunc(lab_to_gridpos(center, bbox_min, bbox_range));
		const uint3 gridpos_from = gridpos - min(grid_bothdirs, gridpos);
		const uint3 gridpos_to   = min(gridpos + grid_bothdirs, GRID_SIZE - 1);

		uint newcenter_count = 0;
		float3 newcenter     = float3(0, 0, 0);
		for(uint gx = gridpos_from.x; gx <= gridpos_to.x; ++gx)
			for(uint gy = gridpos_from.y; gy <= gridpos_to.y; ++gy)
				for(uint gz = gridpos_from.z; gz <= gridpos_to.z; ++gz) {
					groupdesc_t group = params[0].group_ranges[gx][gy][gz];
					for(; group.start_idx != group.end_idx; ++group.start_idx) {
						const uint i = groups_data[group.start_idx];
						float3 lab = known_rgbs_bundle[i].lab;

#SMALL_START#
						float3 tmp = lab - center;
						const bool matched = dot(tmp, tmp) <= radiussy_squared;
#if !BRANCHLESS_ADD
						if(matched)
#endif
						{
							FREQ_LOAD
							newcenter_count += FREQ;
							newcenter       += FREQ_MUL lab;
						}
#SMALL_END#
					}
				}

#SMALL_START#
		newcenter /= newcenter_count;
		bool same = newcenter == center;
		if(same)
			break;
		center = newcenter;
	}
	outputs[this.rgb] = center;
}
#SMALL_END#
