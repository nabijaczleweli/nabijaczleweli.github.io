#SMALL_START#
typedef float3 point_t;
#include "shader.h"

[[vk::binding(0)]] RWStructuredBuffer<float3>          outputs;              // HOST_VISIBLE
[[vk::binding(1)]]   StructuredBuffer<params_t>        params;               // DEVICE_LOCAL & HOST_VISIBLE
[[vk::binding(2)]]   StructuredBuffer<known_rgbs_pack> known_rgbs_bundle;    // DEVICE_LOCAL & HOST_VISIBLE
/*            3 */   KNOWN_RGBS_FREQS
[[vk::binding(4)]]   StructuredBuffer<uint>            groups_data;          // DEVICE_LOCAL
[[vk::binding(5)]] RWStructuredBuffer<known_rgbs_pack> current_rgbs_bundle;  // DEVICE_LOCAL

[numthreads(64, 1, 1)]
void main(uint3 DTid : SV_DispatchThreadID) {
	const uint   current_rgbs_start = params[0].current_rgbs_start;
	const uint   current_rgbs_len   = params[0].current_rgbs_len;
	const uint   iter_limit         = params[0].iter_limit;
	const float  radiussy_squared   = params[0].radiussy_squared;
	const float3 bbox_min           = params[0].bbox_min;
	const float3 bbox_range         = params[0].bbox_range;
	const uint3  grid_bothdirs      = params[0].grid_bothdirs;

#SMALL_END#
	uint id = DTid.x;
	if(id >= current_rgbs_len)
		return;
	id += current_rgbs_start;

	known_rgbs_pack this = current_rgbs_bundle[id];
#define center this.lab
	for(uint iter = 0; iter != iter_limit; ++iter) {
#SMALL_START#
		const uint3 gridpos      = lab_to_gridpos(center, bbox_min, bbox_range);
		const uint3 gridpos_from = gridpos - min(grid_bothdirs, gridpos);
		const uint3 gridpos_to   = min(gridpos + grid_bothdirs, GRID_SIZE - 1);

		uint newcenter_count = 0;
		float3 newcenter     = float3(0, 0, 0);
		for(uint gx = gridpos_from.x; gx <= gridpos_to.x; ++gx)
			for(uint gy = gridpos_from.y; gy <= gridpos_to.y; ++gy)
				for(uint gz = gridpos_from.z; gz <= gridpos_to.z; ++gz) {
					groupdesc_t group = params[0].group_ranges[gx][gy][gz];
					for(; group.start_idx != group.end_idx; ++group.start_idx) {
#SMALL_END#
						const uint i = groups_data[group.start_idx];
						INTERROGATED_LOAD

						float3 tmp = interrogated_lab - center;
						const bool matched = dot(tmp, tmp) <= radiussy_squared;
#if !BRANCHLESS_ADD
						if(matched)
#endif
						{
							FREQ_LOAD
							newcenter_count += FREQ;
							newcenter       += FREQ * interrogated_lab;
						}
#SMALL_START#
					}
				}

		newcenter /= newcenter_count;
		bool same = newcenter == center;
		if(same) {
#SMALL_END#
			outputs[this.rgb] = center;
			return;
#SMALL_START#
		}
		center = newcenter;
#SMALL_END#
	}

	uint savein;
	InterlockedAdd(params[0].current_rgbs_next, 1, savein);
	current_rgbs_bundle[savein] = this;
#SMALL_START#
}
#SMALL_END#
